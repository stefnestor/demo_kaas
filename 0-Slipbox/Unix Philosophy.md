# Unix Philosophy

*Source: [Unix philosophy - Wikipedia](https://en.wikipedia.org/wiki/Unix_philosophy)*

````ad-info

The *Unix Philosohpy* is s set of cultural norms and philosohpical approaches to minimalist, modular and reusable software development.

````

The Unix philosophy emphasizes building simple, short, clear, modular, and extensible code that can be easily maintained and repurposed by developers other than its creators. The Unix philosophy favors [composability](https://en.wikipedia.org/wiki/Composability "Composability") as opposed to [monolithic design](https://en.wikipedia.org/wiki/Monolithic_application "Monolithic application").

## Do One Thing, and Do it Well

Unix programs have always been expected to follow the concept of DOTADIW, or "Do One Thing And Do It Well." There are limited sources for the acronym DOTADIW on the Internet, but it is discussed at length during the development and packaging of new operating systems, especially in the Linux community.

## Rules of the Unix Philosophy

In his book *[The Art of Unix Programming](https://en.wikipedia.org/wiki/The_Art_of_Unix_Programming "The Art of Unix Programming")*, [Eric S. Raymond](https://en.wikipedia.org/wiki/Eric_S._Raymond "Eric S. Raymond"), an American programmer and open source advocate, summarizes the Unix philosophy as [KISS Principle](https://en.wikipedia.org/wiki/KISS_Principle "KISS Principle") of "Keep it Simple, Stupid."

He provides a series of design rules:

* Build [modular](https://en.wikipedia.org/wiki/Modularity_(programming) "Modularity (programming)") programs
* Write readable programs
* Use composition
* [Separate mechanisms from policy](https://en.wikipedia.org/wiki/Separation_of_mechanism_and_policy "Separation of mechanism and policy")
* Write simple programs
* Write small programs
* Write transparent programs
* Write robust programs
* Make data complicated when required, not the program
* Build on potential users' expected knowledge
* Avoid unnecessary output
* Write programs which fail in a way that is easy to diagnose
* Value developer time over machine time
* Write [abstract programs that generate code](https://en.wikipedia.org/wiki/Generative_programming "Generative programming") instead of writing code by hand
* [Prototype](https://en.wikipedia.org/wiki/Software_prototyping "Software prototyping") software before polishing it
* Write flexible and open programs
* Make the program and protocols extensible.

*Backlinks:*

````dataview
list from [[Unix Philosophy]] AND -"Changelog"
````
